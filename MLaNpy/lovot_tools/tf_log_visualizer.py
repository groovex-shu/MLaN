"""
Plot the target and groundtruth data in 2D plot with coordinate transform.

Usage:
    python tf_log_visualizer.py map.yaml target.csv groundtruth.csv transform.yaml

- Map YAML file format is based on ROS.
- CSV files are expected to be generated by lovot-tf-logger
    - should contain the following columns:
      `timestamp, tf_stamp, tx, ty, tz, qx, qy, qz, qw,
            cov_stamp, cov_00, cov_01, cov_02, cov_10, cov_11, cov_12, cov_20, cov_21, cov_22`
    - The length of the target and groundtruth data should be the same and the timestamps should be aligned.
    - The coordinate system of the target should be the map coordinate system.
- Transform YAML file
    - represents the transform from the groundtruth coordinate system to the map coordinate system.
    - is expected to contain the following format:
        transform:
        translation:
            - 0.5916842
            - 1.811329
            - 0.3435915
        rotation:
            - -0.004040956
            - 0.004168813
            - 0.7061126
            - -0.7080758
"""
import argparse
from typing import Tuple

import cv2
import matplotlib.pyplot as plt
import numpy as np
import yaml
from matplotlib.animation import FuncAnimation
from matplotlib.patches import Ellipse

from grid_map_util.occupancy_grid import OccupancyGrid
from localization_tools.show_pose import Covariance


def load_csv(file_path: str) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """ Load a CSV file and return the timestamps and points.
    expected format:
        timestamp, tf_stamp, tx, ty, tz, qx, qy, qz, qw,
            cov_stamp, cov_00, cov_01, cov_02, cov_10, cov_11, cov_12, cov_20, cov_21, cov_22
    we only use the timestamp, tx, ty and covariances columns.
    """
    data = np.genfromtxt(file_path, delimiter=',',
                         skip_header=1, usecols=(0, 2, 3, 10, 11, 12, 13, 14, 15, 16, 17, 18))
    timestamps = data[:, 0]
    points = data[:, 1:3].T
    covariances = data[:, 3:].reshape(-1, 3, 3)
    return timestamps, points, covariances


def quaternion_to_yaw(quaternion):
    """ Convert a quaternion into a yaw angle (rotation around z-axis). """
    # Extract the components of the quaternion
    x, y, z, w = quaternion
    # Calculate yaw (rotation around z-axis)
    siny_cosp = 2 * (w * z + x * y)
    cosy_cosp = 1 - 2 * (y * y + z * z)
    yaw = np.arctan2(siny_cosp, cosy_cosp)
    return yaw


def load_transform_yaml_as_2d_transform(file_path: str) -> np.ndarray:
    with open(file_path, 'r') as file:
        transform_data = yaml.safe_load(file)
        transform_data = transform_data['transform']
    translation = np.array(transform_data['translation'][:2], dtype=np.float64)
    yaw_angle = quaternion_to_yaw(transform_data['rotation'])
    return np.array([
        [np.cos(yaw_angle), -np.sin(yaw_angle), translation[0]],
        [np.sin(yaw_angle), np.cos(yaw_angle), translation[1]],
    ])


def transform_points_to_image_coordinates(positions: np.ndarray, map_: OccupancyGrid) -> np.ndarray:
    """ Transform points from real world coordinates to image coordinates. """
    pixels = ((positions.T - map_.origin) /
              map_.resolution + 0.5).astype(np.int32)
    pixels = np.vstack([pixels[:, 0], map_.img.shape[0] - pixels[:, 1] - 1])
    return pixels


def plot_covariance_ellipse(ax: plt.Axes, mean: np.ndarray, covariance: np.ndarray,
                            resolution: float = 0.05, color: str = 'blue') -> None:
    """ Plot a covariance ellipse. """
    radius, angle = Covariance(covariance).sigma_ellipse()
    radius /= resolution
    # radius *= 10
    angle = np.degrees(angle)
    ellipse = Ellipse(xy=mean, width=radius[0], height=radius[1],
                      angle=angle, edgecolor=color, fc='None', lw=1)
    ax.add_patch(ellipse)


def parse_args():
    parser = argparse.ArgumentParser(
        description='Visualize CSV data in 2D plot with coordinate transform.')
    parser.add_argument('map_yaml', type=str,
                        help='Filename of the YAML file containing the map parameters')
    parser.add_argument('file_target', type=str,
                        help='Filename of the evaluation target CSV')
    parser.add_argument('file_groundtruth', type=str,
                        help='Filename of the groundtruth CSV')
    parser.add_argument('--file_transform', type=str,
                        help='Filename of the YAML file containing transform parameters')
    return parser.parse_args()


def run() -> None:
    args = parse_args()

    # Load map
    map_ = OccupancyGrid.from_yaml_file(args.map_yaml)
    img = cv2.cvtColor(map_.img, cv2.COLOR_GRAY2RGB)

    # Load transform to the map coordinates
    if args.file_transform:
        trans_mat = load_transform_yaml_as_2d_transform(args.file_transform)
    else:
        trans_mat = np.eye(3)[:2, :]

    # Load files
    timestamps_target, target_points, covariances = load_csv(args.file_target)
    timestamps_gt, groundtruth_points, _ = load_csv(args.file_groundtruth)
    assert np.array_equal(timestamps_target, timestamps_gt), "Timestamps are not aligned"

    timestamps = timestamps_target - timestamps_target[0]

    # Apply transform and calculate L2 norm
    groundtruth_points = trans_mat @ np.vstack(
        (groundtruth_points, np.ones(groundtruth_points.shape[1])))
    l2_norm = np.linalg.norm(target_points - groundtruth_points, axis=0)

    # Transform the points to image coordinates
    target_points = transform_points_to_image_coordinates(target_points, map_)
    groundtruth_points = transform_points_to_image_coordinates(
        groundtruth_points, map_)

    # Calculate bounds for the L2 norm plot
    max_l2 = np.max(l2_norm)
    max_l2 = 1.0
    max_ts = np.max(timestamps)

    # Visualize
    fig, axs = plt.subplots(2, 1, figsize=(10, 8))

    def update(frame):
        start_index = max(0, frame - 10)
        axs[0].clear()
        axs[0].imshow(img, cmap='gray')
        axs[0].scatter(target_points[0, start_index:frame+1],
                       target_points[1, start_index:frame+1],
                       c='blue', s=1, label='Target')
        axs[0].scatter(groundtruth_points[0, start_index:frame+1],
                       groundtruth_points[1, start_index:frame+1],
                       c='red', s=1, label='Groundtruth')
        plot_covariance_ellipse(axs[0], target_points[:, frame], covariances[frame])

        axs[0].legend()

        axs[1].clear()
        axs[1].plot(timestamps[:frame], l2_norm[:frame], c='green')
        axs[1].set_xlabel('Timestamp')
        axs[1].set_ylabel('L2 Norm Error')
        axs[1].set_xlim([0, max_ts])
        axs[1].set_ylim([0, max_l2])

    ani = FuncAnimation(
        fig, update, frames=target_points.shape[1], interval=1)

    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    run()
